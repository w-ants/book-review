
# [The Programmer's Brain](https://livebook.manning.com/book/the-programmers-brain/)
![image](https://user-images.githubusercontent.com/26742874/198227741-92c14a0d-2228-4044-815f-97ef9b4592f7.png)

## Attendees
[@Darin](https://github.com/DarinKim) [@Engelin](https://github.com/engelin)

## Contents

### Part 1 On reading code better  

1 Decoding your confusion while coding  

1.1 Different kinds of confusion in code
- Confusion type 1: Lack of knowledge
- Confusion type 2: Lack of information
- Confusion type 3: Lack of processing power

1.2 Different cognitive processes that affect coding
- LTM and programming
- STM and programming
- Working memory and programming

1.3 Cognitive processes in collaboration
- A brief dissection of how the cognitive processes interacted
- Cognitive processes regarding programming tasks

2 Speed reading for code  

2.1 Quickly reading code
- What just happened in your brain?
- Reexamine your reproduction
- Reexamining your second attempt at reproducing code
- Why is reading unfamiliar code hard?

2.2 Overcoming size limits in your memory
- The power of chunking
- Expert programmers can remember code better than beginners

2.3 You see more code than you can read
- Iconic memory
- It’s not what you remember; it’s the way you remember it
- Practice chunking

3 How to learn programming syntax quickly

3.1 Tips for remembering syntax
- Disruptions play havoc with your workflow

3.2 How to learn syntax quickly with flashcards
- When to use the flashcards
- Expanding the set of flashcards
- Thinning the set of flashcards

3.3 How to not forget things
- Why do we forget memories?
- Spaced repetition

3.4 How to remember syntax longer
- Two forms of remembering information
- Just seeing information is not enough
- Remembering information strengthens memories
- Strengthen memories by actively thinking

4 How to read complex code

4.1 Why it’s hard to understand complex code
- What’s the difference between working memory and STM?
- Types of cognitive load as they relate to programming

4.2 Techniques to reduce cognitive load
- Refactoring
- Replacing unfamiliar language constructs
- Code synonyms are great additions to a flashcard deck

4.3 Memory aids to use when your working memory is overloaded
- Creating a dependency graph
- Using a state table
- Combining dependency graphs and state tables


### Part 2 On thinking about code

5 Reaching a deeper understanding of code

5.1 Roles of variables framework
- Different variables do different things
- Eleven roles to cover almost all variables

5.2 Roles and paradigms
- Benefits of roles
- Hungarian notation

5.3 Gaining a deeper knowledge of programs
- Text knowledge vs. plan knowledge
- Different stages of program understanding

5.4 Reading text is similar to reading code
- What happens in the brain when we read code?
- If you can learn French, you can learn Python

5.5 Text comprehension strategies applied to code
- Activating prior knowledge
- Monitoring
- Determining the importance of different lines of code
- Inferring the meaning of variable names
- Visualizing
- Questioning
- Summarizing code

6 Getting better at solving programming problems

6.1 Using models to think about code
- The benefits of using models

6.2 Mental models
- Examining mental models in detail
- Learning new mental models
- How to use mental models efficiently when thinking about code

6.3 Notional machines
- What is a notional machine?
- Examples of notional machines
- Different levels of notional machines

6.4 Notional machines and language
- Expanding sets of notional machines
- Different notional machines can create conflicting mental models

6.5 Notional machines and schemata
- Why schemata matters
- Are notional machines semantics?

7 Misconceptions: Bugs in thinking

7.1 Why learning a second programming language is easier than learning the first one
- How to increase the chances of benefiting from existing programming knowledge
- Different forms of transfer
- Already knowing something: Curse or blessing?
- The difficulties of transfer

7.2 Misconceptions: Bugs in thinking
- Debugging misconceptions with conceptual change
- Suppressing misconceptions
- Misconceptions about programming languages
- Preventing misconceptions while learning a new programming language
- Diagnosing misconceptions in a new codebase


### Part 3 On writing better code

8 How to get better at naming things

8.1 Why naming matters
- Why naming matters
- Different perspectives on naming
- Initial naming practices have a lasting impact

8.2 Cognitive aspects of naming
- Formatting names supports your STM
- Clear names help your LTM
- Variable names can contain different types of information to help you understand them
- When to evaluate the quality of names

8.3 What types of names are easier to understand?
- To abbreviate or not to abbreviate?
- Snake case or camel case?

8.4 The influence of names on bugs
- Code with bad names has more bugs

8.5 How to choose better names
- Name molds
- Feitelson’s three-step model for better variable names

9 Avoiding bad code and cognitive load: Two frameworks

9.1 Why code with code smells creates a lot of cognitive load
- A brief intro to code smells
- How code smells harm cognition

9.2 The influence of bad names on cognitive load
- Linguistic antipatterns
- Measuring cognitive load
- Linguistic antipatterns and cognitive load
- Why linguistic antipatterns cause confusion

10 Getting better at solving complex problems

10.1 What is problem solving?
- Elements of problem solving
- State space

10.2 What is the role of the LTM when you solve programming problems?
- Is problem solving a cognitive process on its own?
- How to teach your LTM to solve problems
- Two types of memories that play a role in problem solving

10.3 Automatization: Creating implicit memories
- Implicit memories over time
- Why automatization will make you program quicker
- Improving implicit memories

10.4 Learning from code and its explanation
- A new type of cognitive load: Germane load
- Using worked examples in your working life


### Part 4 On collaborating on code

11 The act of writing code

11.1 Different activities while programming
- Searching
- Comprehension
- Transcription
- Incrementation
- Exploration
- What about debugging?

11.2 Programmer interrupted
- Programming tasks require a warm-up
- What happens after an interruption?
- How to better prepare for interruptions
- When to interrupt a programmer
- Some thoughts on multitasking

12 Designing and improving larger systems

12.1 Examining the properties of codebases
- Cognitive dimensions
- Using CDCB to improve your codebase
- Design maneuvers and their trade-offs

12.2 Dimensions and activities
- Impact of dimensions on different activities
- Optimizing your codebase for expected activities

13 How to onboard new developers

13.1 Issues in the onboarding process

13.2 Differences between experts and novices
- Beginners’ behavior in more depth
- Difference between seeing concepts concretely and abstractly

13.3 Activities for a better onboarding process
- Limit tasks to one programming activity
- Support the memory of the onboardee
- Read code together
- Some words to close this book

epilogue

